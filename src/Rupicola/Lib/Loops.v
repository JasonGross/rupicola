From Coq Require Recdef.
Require Import Rupicola.Lib.Api.

Module Type ExitToken_sig.
  Axiom t : Set.
  Axiom new : bool -> t.
  Axiom get : t -> bool.
  Axiom set : t -> t.
End ExitToken_sig.

Module ExitToken <: ExitToken_sig.
  Definition t := bool.
  Definition new (b: bool) : t := b.
  Definition get (tok: t) : bool := tok.
  Definition set (tok: t) : t := true.
  Definition branch {A} (tok: t) (set unset: A) :=
    if tok then set else unset.
End ExitToken.

Section Gallina.
  Open Scope Z_scope.

  Context {A}
          (from to step: Z)
          (body: forall (tok: ExitToken.t) (idx: Z) (acc: A),
              from <= idx < to -> (ExitToken.t * A)).

  Lemma ranged_for'_1 {idx} :
    from <= idx ->
    idx < to ->
    from <= idx < to.
  Proof. lia. Qed.

  Lemma ranged_for'_2 {idx k} :
    from <= idx ->
    from <= idx + Z.max 1 k.
  Proof. lia. Qed.

  Lemma ranged_for'_termination {idx k}:
    idx < to ->
    to - (idx + Z.max 1 k) < to - idx.
  Proof.
    intros. (* This reduces faster than a the proof generated by ‘lia’ *)
    match goal with
    | [  |- ?a < ?b ] =>
      destruct (Z.lt_decidable a b) as [Hlt | Hge];
        [ exact Hlt | exfalso; lia ]
    end.
  Defined.

  (* Require Import Equations.Equations. *)

  (* Equations ranged_for' (a0: A) idx (Hle: from <= idx) : A by wf (to - idx) lt := *)
  (*   ranged_for' a0 idx Hle with le_gt_dec to idx => { *)
  (*     ranged_for' a0 idx Hle (left _) := a0; *)
  (*     ranged_for' a0 idx Hle (right Hgt) := *)
  (*       let (tok, a0) := body (ExitToken.new false) idx a0 (ranged_for'_1 Hle Hgt) in *)
  (*       if ExitToken.get tok then a0 *)
  (*       else ranged_for' a0 (idx + S (pred step)) (ranged_for'_2 Hle) *)
  (*   }. *)
  (* Next Obligation. lia. Qed. *)

  (* Program Fixpoint ranged_for' (a0: A) idx (Hle: from <= idx) {measure (to - idx)} : A := *)
  (*   match le_gt_dec to idx with *)
  (*   | left _ => a0 *)
  (*   | right Hgt => *)
  (*     let (tok, a0) := body (ExitToken.new false) idx a0 (ranged_for'_1 Hle Hgt) in *)
  (*     if ExitToken.get tok then a0 *)
  (*     else ranged_for' a0 (idx + S (pred step)) (ranged_for'_2 Hle) *)
  (*   end. *)
  (* Next Obligation. lia. Qed. *)

  (* FIXME Is ExitToken the right API for continue?. *)
  Function ranged_for' (a0: A) idx (Hle: from <= idx) {measure (fun n => Z.to_nat (to - n)) idx} : A :=
    match Z_lt_dec idx to with
    | left Hlt =>
      let '(tok, a0) := body (ExitToken.new false) idx a0 (ranged_for'_1 Hle Hlt) in
      if ExitToken.get tok then a0
      else ranged_for' a0 (idx + Z.max 1 step) (ranged_for'_2 Hle)
    | right _ => a0
    end.
  Proof. lia. Defined.   (* FIXME *)
  (* intros; apply ranged_for'_termination; assumption. Defined. *)
  Global Opaque ranged_for'.

  Definition ranged_for (a0: A) :=
    ranged_for' a0 from (Z.le_refl _).

  Definition Z_must_lt (a b: Z) : if Z_lt_dec a b then a < b else True.
  Proof. destruct Z_lt_dec; (assumption || exact I). Defined.
  Definition Z_must_gt (a b: Z) : if Z_gt_dec a b then a > b else True.
  Proof. destruct Z_gt_dec; (assumption || exact I). Defined.
  Definition Z_must_pos (a: Z) : if Z_gt_dec a 0 then a > 0 else True :=
    Z_must_gt a 0.

  Section Induction.
    Context (P: A -> Prop) (a0: A).

    Context (H0: P a0).
    Context (Hbody: forall tok idx a1 Hle, P a1 -> P (snd (body tok idx a1 Hle))).

    Lemma ranged_for'_ind' :
      forall idx Hle,
        P (ranged_for' a0 idx Hle).
    Proof.
      intros.
      revert H0 Hbody.
      apply ranged_for'_ind;
        repeat match goal with
               | _ => progress (subst || intros || cbn in * )
               | [ H: _ = _ |- _ ] => apply (f_equal snd) in H
               | _ => eauto
               end.
    Qed.

    Lemma ranged_for_ind :
      P (ranged_for a0).
    Proof. eapply ranged_for'_ind'. Qed.
  End Induction.
End Gallina.

Open Scope Z_scope.

Section with_parameters.
  Context {semantics : Semantics.parameters}
          {semantics_ok : Semantics.parameters_ok semantics}.

  Context {A: Type}
          (from to step: word).

  Section Generic.
    Context {to_Z: word -> Z}
            (to_Z_of_Z: forall l h w,
                to_Z l <= w <= to_Z h ->
                to_Z (word.of_Z w) = w).

    Context (Hgt: to_Z step > 0).
    Context (body: forall (tok: ExitToken.t) (idx: word) (acc: A),
              to_Z from <= to_Z idx < to_Z to ->
              (ExitToken.t * A)).

    Program Definition ranged_for_w (a0: A) : A :=
      ranged_for (to_Z from) (to_Z to) (to_Z step)
                 (fun tok idx acc pr =>
                    body tok (word.of_Z idx) acc _)
                 a0.
    Next Obligation.
      erewrite (to_Z_of_Z from to); lia.
    Qed.

    Section Induction.
      Context (P: A -> Prop) (a0: A).
      Context (H0: P a0).
      Context (Hbody: forall tok idx a1 Hle, P a1 -> P (snd (body tok idx a1 Hle))).

      Lemma ranged_for_w_ind : P (ranged_for_w a0).
      Proof. unfold ranged_for_w; apply ranged_for_ind; auto. Qed.
    End Induction.
  End Generic.

  Section Unsigned.
    Lemma word_unsigned_of_Z_bracketed l h w:
      word.unsigned l <= w <= word.unsigned h ->
      word.unsigned (word.of_Z w) = w.
    Proof.
      pose proof word.unsigned_range l.
      pose proof word.unsigned_range h.
      intros; rewrite word.unsigned_of_Z, word.wrap_small; lia.
    Qed.

    Definition ranged_for_u :=
      ranged_for_w word_unsigned_of_Z_bracketed.

    Definition ranged_for_u_ind :=
      ranged_for_w_ind word_unsigned_of_Z_bracketed.
  End Unsigned.

  Section Signed.
    Lemma word_signed_of_Z_bracketed l h w:
      word.signed l <= w <= word.signed h ->
      word.signed (word.of_Z w) = w.
    Proof.
      pose proof word.signed_range l.
      pose proof word.signed_range h.
      intros; rewrite word.signed_of_Z, word.swrap_inrange; lia.
    Qed.

    Definition ranged_for_s :=
      ranged_for_w word_signed_of_Z_bracketed.

    Definition ranged_for_s_ind :=
      ranged_for_w_ind word_signed_of_Z_bracketed.
  End Signed.

  Definition wZ_must_pos (a: Z) :
    match Z_gt_dec a 0, Z_le_dec a (2 ^ 32 - 1) with
    | left _, left _ => word.unsigned (word.of_Z a) > 0
    | _, _ => True
    end.
  Proof.
    destruct Z_le_dec, Z_gt_dec; [ | exact I .. ].
    assert (2 ^ 32 - 1 <= 2 ^ Semantics.width - 1) by
        (destruct Semantics.width_cases as [-> | ->]; lia).
    rewrite word.unsigned_of_Z, word.wrap_small; lia.
  Qed.
End with_parameters.

Section with_parameters.
  Context {semantics : Semantics.parameters}
          {semantics_ok : Semantics.parameters_ok semantics}.

  Definition ranged_for_widen_bounds {from idx from' to} :
    from <= idx < from' ->
    from' < to ->
    from <= idx < to.
  Proof. lia. Qed.

  Section Generic.
    Context {to_Z: word -> Z}
            (to_Z_of_Z: forall l h w,
                to_Z l <= w <= to_Z h ->
                to_Z (word.of_Z w) = w).

    Lemma compile_ranged_for_w A {tr mem locals functions}
          (from to step: word) body (a0: A) :
      let v := ranged_for_w from to step to_Z_of_Z body a0 in
      forall {P} {pred: P v -> predicate}
        (loop_pred: word -> A -> predicate)
        {k: nlet_eq_k P v} {k_impl} {body_impl}
        (from_var to_var step_var: string) vars,

        let lp from '(tok, acc) tr mem locals :=
            loop_pred (ExitToken.branch tok (word.sub to (word.of_Z 1)) from) acc tr mem locals in

        (forall from a0 tr mem locals,
            loop_pred from a0 tr mem locals ->
            map.getmany_of_list locals [from_var; to_var; step_var] =
            Some [from; to; step]) ->

        loop_pred from a0 tr mem locals ->

        ((* loop body *)
          let lp := lp in
          forall tr mem locals from'
            (Hle: to_Z from <= to_Z from')
            (Hlt: to_Z from' < to_Z to),
            let tok := ExitToken.new false in
            let a := ranged_for_w from from' step to_Z_of_Z
                                 (fun tok idx acc pr =>
                                    body tok idx acc (ranged_for_widen_bounds pr Hlt)) a0 in
            loop_pred from' a tr mem locals ->
            (<{ Trace := tr;
                Memory := mem;
                Locals := locals;
                Functions := functions }>
             body_impl
             <{ lp from' (body tok from' a (conj Hle Hlt)) }>)) ->
        (let v := v in
         forall tr mem locals,
           loop_pred to v tr mem locals ->
           (<{ Trace := tr;
               Memory := mem;
               Locals := locals;
               Functions := functions }>
            k_impl
            <{ pred (k v eq_refl) }>)) ->
        <{ Trace := tr;
           Memory := mem;
           Locals := locals;
           Functions := functions }>
        cmd.seq
          (cmd.while
             (expr.op bopname.ltu (expr.var from_var) (expr.var to_var))
             (cmd.seq
                body_impl
                (cmd.set from_var
                         (expr.op bopname.add
                                  (expr.var from_var)
                                  (expr.literal 1)))))
          k_impl
        <{ pred (nlet_eq vars v k) }>.
    Proof.
      cbv zeta.
      repeat straightline'.
    Admitted.
  End Generic.

  Definition compile_ranged_for_u :=
    compile_ranged_for_w word_unsigned_of_Z_bracketed.

  Definition compile_ranged_for_s :=
    compile_ranged_for_w word_signed_of_Z_bracketed.
End with_parameters.

Require Import Rupicola.Lib.Arrays.
Require Import Rupicola.Examples.Cells.Cells.

Section Ex.
  Context {semantics : Semantics.parameters}
          {semantics_ok : Semantics.parameters_ok semantics}.

   Notation "∅" := map.empty.
   Notation "m [[ k ← v ]]" :=
     (map.put m k v)
       (left associativity, at level 11,
        format "m [[ k  ←  v ]]").

   Lemma signed_lt_unsigned w:
     word.signed w <= word.unsigned w.
   Proof.
     pose proof word.unsigned_range w.
     rewrite word.signed_unsigned_dec.
     destruct Z_lt_le_dec; lia.
   Qed.

  Instance Convertible_word_Nat : Convertible word nat :=
    fun w => Z.to_nat (word.unsigned w).
  Instance HasDefault_word : HasDefault word :=
    word.of_Z 0.

    Program Definition vect_memcpy {n1 n2} (len: word)
           (a1: VectorArray.t word n1)
           (a2: VectorArray.t word n2)
           (pr1: word.unsigned len < Z.of_nat n1)
           (pr2: word.unsigned len < Z.of_nat n2) :=
     let/n from := word.of_Z 0 in
     let/n step := word.of_Z 1 in
     let/n a2 := ranged_for_u
                  from len step
                  (fun tok idx a2 Hlt =>
                     let/n v := VectorArray.get a1 idx _ in
                     let/n a2 := VectorArray.put a2 idx _ v in
                     (tok, a2)) a2 in
     (a1, a2).
    Next Obligation.
      pose proof word.unsigned_range idx.
      pose proof word.unsigned_range len.
      unfold cast, Convertible_word_Nat.
      lia.
    Qed.
    Next Obligation.
      pose proof word.unsigned_range idx.
      pose proof word.unsigned_range len.
      unfold cast, Convertible_word_Nat.
      lia.
    Qed.

   Instance spec_of_vect_memcpy : spec_of "vect_memcpy" :=
     fnspec "vect_memcpy" (len: word) (a1_ptr a2_ptr : address) /
            {n1} (a1: VectorArray.t word n1)
            {n2} (a2: VectorArray.t word n2)
            (pr1: word.unsigned len < Z.of_nat n1)
            (pr2: word.unsigned len < Z.of_nat n2)
            R,
     { requires tr mem :=
         (word_vectorarray_value a1_ptr a1 ⋆
          word_vectorarray_value a2_ptr a2 ⋆ R) mem;
       ensures tr' mem' :=
         tr' = tr /\
         let res := vect_memcpy len a1 a2 pr1 pr2 in
         (word_vectorarray_value a1_ptr (fst res) ⋆
          word_vectorarray_value a2_ptr (snd res) ⋆ R) mem' }.

   Derive vect_memcpy_body SuchThat
          (defn! "vect_memcpy"("len", "a1", "a2") { vect_memcpy_body },
           implements @vect_memcpy)
          As vect_memcpy_correct.
   Proof.
     compile_setup.

     repeat compile_step.

     simple apply compile_nlet_as_nlet_eq.
     eapply compile_ranged_for_u with (loop_pred := (fun idx a2 tr' mem' locals' =>
         tr' = tr /\
         locals' = (∅[["len" ← len]][["a1" ← a1_ptr]][["a2" ← a2_ptr]]
                     [["from" ← idx]][["step" ← word.of_Z 1]]) /\
         (word_vectorarray_value a1_ptr a1 * word_vectorarray_value a2_ptr a2 * R)%sep mem')).

     all: repeat compile_step; compile_done.
   Qed.

   Program Definition vect_memcpy_s {n1 n2} (len: word)
           (a1: VectorArray.t word n1)
           (a2: VectorArray.t word n2)
           (pr1: word.signed len < Z.of_nat n1)
           (pr2: word.signed len < Z.of_nat n2) :=
     let/n from eq:_ := word.of_Z 0 in
     let/n step := word.of_Z 1 in
     let/n a2 := ranged_for_s
                  from len step
                  (fun tok idx a2 Hlt =>
                     let/n v := VectorArray.get a1 idx _ in
                     let/n a2 := VectorArray.put a2 idx _ v in
                     (tok, a2)) a2 in
     (a1, a2).
   Next Obligation.
     pose proof word.half_modulus_pos.
     unfold cast, Convertible_word_Nat.
     rewrite word.signed_of_Z, word.swrap_inrange in H0 by lia.
     rewrite word.signed_gz_eq_unsigned; lia.
   Qed.
   Next Obligation.
     pose proof word.half_modulus_pos.
     unfold cast, Convertible_word_Nat.
     rewrite word.signed_of_Z, word.swrap_inrange in H0 by lia.
     rewrite word.signed_gz_eq_unsigned; lia.
   Qed.


   Instance spec_of_vect_memcpy_s : spec_of "vect_memcpy_s" :=
     fnspec "vect_memcpy_s" (len: word) (a1_ptr a2_ptr : address) /
            {n1} (a1: VectorArray.t word n1)
            {n2} (a2: VectorArray.t word n2)
            (pr1: word.signed len < Z.of_nat n1)
            (pr2: word.signed len < Z.of_nat n2)
            R,
     { requires tr mem :=
         (word_vectorarray_value a1_ptr a1 ⋆
          word_vectorarray_value a2_ptr a2 ⋆ R) mem;
       ensures tr' mem' :=
         tr' = tr /\
         let res := vect_memcpy_s len a1 a2 pr1 pr2 in
         (word_vectorarray_value a1_ptr (fst res) ⋆
          word_vectorarray_value a2_ptr (snd res) ⋆ R) mem' }.

   Derive vect_memcpy_s_body SuchThat
          (defn! "vect_memcpy_s"("len", "a1", "a2") { vect_memcpy_s_body },
           implements @vect_memcpy_s)
          As vect_memcpy_s_correct.
   Proof.
     compile_setup.

     repeat compile_step.

     simple apply compile_nlet_as_nlet_eq.
     unfold ranged_for_s;
       simple eapply compile_ranged_for_s with (loop_pred := (fun idx a2 tr' mem' locals' =>
         tr' = tr /\
         locals' = (∅[["len" ← len]][["a1" ← a1_ptr]][["a2" ← a2_ptr]]
                     [["from" ← idx]][["step" ← v0]]) /\
         (word_vectorarray_value a1_ptr a1 * word_vectorarray_value a2_ptr a2 * R)%sep mem')).

     all: repeat compile_step; compile_done.
   Qed.

   Definition sizedlist_memcpy (len: word)
           (a1: ListArray.t word)
           (a2: ListArray.t word) :=
     let/n from := word.of_Z 0 in
     let/n step := word.of_Z 1 in
     let/n a2 := ranged_for_u
                  from len step
                  (fun tok idx a2 Hlt =>
                     let/n v := ListArray.get a1 idx in
                     let/n a2 := ListArray.put a2 idx v in
                     (tok, a2)) a2 in
     (a1, a2).

   Instance spec_of_sizedlist_memcpy : spec_of "sizedlist_memcpy" :=
     fnspec "sizedlist_memcpy" (len: word) (a1_ptr a2_ptr : address) /
            {n1} (a1: ListArray.t word)
            {n2} (a2: ListArray.t word)
            (pr1: word.unsigned len < Z.of_nat n1)
            (pr2: word.unsigned len < Z.of_nat n2)
            R,
     { requires tr mem :=
         (word_sizedlistarray_value a1_ptr n1 a1 ⋆
          word_sizedlistarray_value a2_ptr n2 a2 ⋆ R) mem;
       ensures tr' mem' :=
         tr' = tr /\
         let res := sizedlist_memcpy len a1 a2 in
         (word_sizedlistarray_value a1_ptr n1 (fst res) ⋆
          word_sizedlistarray_value a2_ptr n2 (snd res) ⋆ R) mem' }.

   Derive sizedlist_memcpy_body SuchThat
         (defn! "sizedlist_memcpy"("len", "a1", "a2") { sizedlist_memcpy_body },
          implements sizedlist_memcpy)
         As sizedlist_memcpy_correct.
   Proof.
     compile_setup.

     repeat compile_step.

     simple apply compile_nlet_as_nlet_eq.
     eapply compile_ranged_for_u with (loop_pred := (fun idx a2 tr' mem' locals' =>
         tr' = tr /\
         locals' = (∅[["len" ← len]][["a1" ← a1_ptr]][["a2" ← a2_ptr]]
                     [["from" ← idx]][["step" ← word.of_Z 1]]) /\
         (word_sizedlistarray_value a1_ptr n1 a1 *
          word_sizedlistarray_value a2_ptr n2 a2 * R)%sep mem')).

     all: repeat compile_step; try lia; compile_done.
   Qed.

   Definition unsizedlist_memcpy (len: word)
           (a1: ListArray.t word)
           (a2: ListArray.t word) :=
     let/n from := word.of_Z 0 in
     let/n step := word.of_Z 1 in
     let/n a2 := ranged_for_u
                  from len step
                  (fun tok idx a2 Hlt =>
                     let/n v := ListArray.get a1 idx in
                     let/n a2 := ListArray.put a2 idx v in
                     (tok, a2)) a2 in
     (a1, a2).

   Instance spec_of_unsizedlist_memcpy : spec_of "unsizedlist_memcpy" :=
     fnspec "unsizedlist_memcpy" (len: word) (a1_ptr a2_ptr : address) /
            (a1: ListArray.t word) (a2: ListArray.t word)
            (pr1: word.unsigned len < Z.of_nat (List.length a1))
            (pr2: word.unsigned len < Z.of_nat (List.length a2))
            R,
     { requires tr mem :=
         (word_listarray_value a1_ptr a1 ⋆
          word_listarray_value a2_ptr a2 ⋆ R) mem;
       ensures tr' mem' :=
         tr' = tr /\
         let res := unsizedlist_memcpy len a1 a2 in
         (word_listarray_value a1_ptr (fst res) ⋆
          word_listarray_value a2_ptr (snd res) ⋆ R) mem' }.

   Derive unsizedlist_memcpy_body SuchThat
         (defn! "unsizedlist_memcpy"("len", "a1", "a2") { unsizedlist_memcpy_body },
          implements unsizedlist_memcpy)
         As unsizedlist_memcpy_correct.
   Proof.
     compile_setup.

     repeat compile_step.

     simple apply compile_nlet_as_nlet_eq.
     eapply compile_ranged_for_u with (loop_pred := (fun idx a2 tr' mem' locals' =>
         tr' = tr /\
         locals' = (∅[["len" ← len]][["a1" ← a1_ptr]][["a2" ← a2_ptr]]
                     [["from" ← idx]][["step" ← word.of_Z 1]]) /\
         (word_listarray_value a1_ptr a1 *
          word_listarray_value a2_ptr a2 * R)%sep mem')).

     (*  FIXME remove previous hints *)
     (* Import UnsizedListArrayCompiler. *)
     Hint Extern 1 => simple eapply @compile_word_unsizedlistarray_get; shelve : compiler.
     Hint Extern 1 => simple eapply @compile_word_unsizedlistarray_put; shelve : compiler.

     all: repeat compile_step; compile_done; unfold id.

     { lia. (* loop index in bounds + function precondition *) }
     { (* Note the call to induction.
          Without vectors or the sizedlist predicate, we need to check that the index is in bounds but we modified the array.
          Using a vector type instead keeps the information in the type and the statement of put specifies that the length is preserved.
          Putting that info in the representation predicates has a similar effect.
          Without this, we need to perform induction explicitly. *)
       subst a.
       apply ranged_for_u_ind.
       - lia.
       - intros; unfold nlet; cbn.
         rewrite ListArray.put_length.
         assumption. }
   Qed.

   Program Definition incr_gallina (c: cell) : cell :=
     let/n one := word.of_Z 1 in
     let/n from := word.of_Z 3 in
     let/n to := word.of_Z 5 in
     let/n step := word.of_Z 1 in
     let/n tick := word.of_Z 0 in
     let/n (tick, c) :=
        ranged_for_u (A := word * cell)
                     from to step
                     (fun tok idx acc bounded =>
                        let '(tick, c) := acc in
                        let/n v := get c in
                        let/n v := word.add v idx in
                        let/n c := put v c in
                        let/n tick := word.add tick one in
                        (tok, (tick, c)))
                     (tick, c) : word * cell in
     (let/n v := get c in
      let/n v := word.add v tick in
      let/n c := put v c in
      c).

   Instance spec_of_incr : spec_of "incr" :=
     fnspec "incr" c_ptr / (c: cell) R,
     { requires tr mem :=
         (cell_value c_ptr c ⋆ R) mem;
       ensures tr' mem' :=
         tr' = tr /\
         (cell_value c_ptr (incr_gallina c) ⋆ R) mem' }.

   Derive incr_body SuchThat
         (defn! "incr"("c") { incr_body },
          implements incr_gallina)
         As body_correct.
   Proof.
     compile_setup.

     repeat compile_step.

     simple apply compile_nlet_as_nlet_eq.
     eapply compile_ranged_for_u with (loop_pred := (fun idx acc tr' mem' locals' =>
         let '(tick, c) := acc in
         tr' = tr /\
         (* locals' = map.put locals "tick" tick /\ *)
         locals' = (∅[["c" ← c_ptr]][["one" ← v]]
                     [["from" ← idx]][["to" ← v1]][["step" ← v2]]
                     [["tick" ← tick]]) /\
         (cell_value c_ptr c * R)%sep mem')).

     all: repeat compile_step; compile_done.
   Qed.
End Ex.

(* Require Import bedrock2.NotationsCustomEntry. *)
(* Require Import bedrock2.NotationsInConstr. *)
(* Eval cbv [sizedlist_memcpy_body unsizedlist_memcpy_body vect_memcpy_s_body fold_right noskips is_skip] in sizedlist_memcpy_body. *)

Require bedrock2.BasicC64Semantics.

Module test.
  Import BasicC64Semantics.

  Time Compute (ranged_for 0 15 3
                        (fun t idx acc _ =>
                           if Z.ltb 11 idx then
                             let t' := ExitToken.set t in
                             (t', acc)
                           else
                             let acc := idx :: acc in
                             (t, acc)) []).

  Time Compute (ranged_for_u (word.of_Z 0) (word.of_Z 15) (word.of_Z 3)
                          (fun t idx acc _ =>
                             if word.ltu (word.of_Z 11) idx then
                               let t' := ExitToken.set t in
                               (t', acc)
                             else
                               let acc := idx :: acc in
                               (t, acc)) []).
End test.
